<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.10 (457750)"/><meta name="author" content="jmrobertson@protonmail.com"/><meta name="created" content="2019-06-05 22:34:38 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-06-06 11:23:14 +0000"/><title>3 User Input</title></head><body><div>All user input is untrusted: how to handle it</div><div><br/></div><div>-lots of attacks involve submitting unexpected input -&gt; behavior not intended by app designers</div><div>-user input that is correct needs to be handled safely</div><div><br/></div><div><span style="font-size: 18px; font-weight: bold; text-decoration: underline;">Varieties of Input</span></div><div>-strings, numbers, length variations, arbitrary (think blogs)</div><div><br/></div><div>needs to:</div><ol><li><div>store input in db</div></li><li><div>write to disk</div></li><li><div>display it back to users in a safe way</div></li></ol><div><br/></div><div>input can be generated by app too, travels server/client/server during session management</div><div>-this can be validated by app well, since the app generated it and knows what to expect</div><div>-server generated data = modified tells application vuln probing is happening</div><ol><li><div>reject request</div></li><li><div>log incident</div></li></ol><div><br/></div><div><span style="font-size: 18px; font-weight: bold; text-decoration: underline;">Approaches to Input Handling</span></div><div><br/></div><div><span style="font-style: italic; text-decoration: underline;">Reject Known Bad</span></div><div>-blacklist w/ set of literal  strings/patterns known to be used in attacks</div><div>-input validation mechanism blocks anything on blacklist</div><div>-regarded as least effective approach: hard to match blacklist to fuzz-type input, and hard to evolve blacklist w/ exploit evolution</div><ul><li><div>SELECT blocked, SeLeCt works</div></li><li><div>1=1— blocked, 2=2— works</div></li></ul><div>-can often be bypassed by nonstandard characters b/t expressions: disrupts tokenizing performed by application</div><div>-NULL byte attacks</div><ul><li><div>    inserting a null byte before a blocked epxression can cause some filters to stop processing input, and not ID the input</div></li></ul><div><br/></div><div><span style="font-size: 14px;"><span style="font-size: 14px; font-style: italic; text-decoration: underline;">Accept known good</span></span></div><div><span style="font-size: 14px;">-whitelist of literal strings/patterns, or set of criteria, known to match only benign input</span></div><div><span style="font-size: 14px;">-validation mechanism: allow data that matches whitlist, block everything up</span></div><div><span style="font-size: 14px;">-when feasible, this is hte most effective way to handle potential malicious input</span></div><div><span style="font-size: 14px;">-someties app fxn reqs != whitelist feasible</span></div><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 14px;"><span style="font-size: 14px; font-style: italic; text-decoration: underline;">Sanitization</span></span></div><div>-recognizes need to accept data that can't be guarenteed as safe</div><div>-accepts input, sanitizes in various ways </div><div>-&gt;remove mal chars, or escape chars</div><div><span style="font-size: 14px;">-usual defense against XSS</span></div><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 14px;"><span style="font-size: 14px; text-decoration: underline; font-style: italic;">Safe Data Handling</span></span></div><div><span style="font-size: 14px;">-many vulns = safe user data processed unsafely</span></div><div><span style="font-size: 14px;">-based on safe programming practices</span></div><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 14px;"><span style="font-size: 14px; font-style: italic; text-decoration: underline;">Semantic Checks</span></span></div><div><span style="font-size: 14px;">-mal input is identical to to user input</span></div><div><span style="font-size: 14px;">-malicious = different circumstances under which it's submitted</span></div><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 18px; font-weight: bold; text-decoration: underline;">Boundary Validation</span></div><div><span style="font-size: 14px;">validating data across trust boundaries </span></div><div><br/></div><div>-input validation on client side may improve performance/UX, do not provide assurance that data actually reaches server</div><div><span style="font-size: 14px;"><br/></span></div><div>-huge trust boundary: where user data is first rec'd by server-side</div><div><br/></div><div>-basic input validation: clean malic data on arrival, pass clean data to trusted app</div><ul><li><div>wide range of functions, different tech in use: defend against huge variety of input-based attacks, boundary defense falls short</div></li><li><div><span style="font-size: 14px;">app fxns = chain together series of processing types. 1 input causes diff operations at different processing points. Malicious data get generated at key stage in processing further in a series</span></div></li><li><div><span style="font-size: 14px;">validation checks for different services (XSS validation vs. command injection validatoin) may be incompatiable w/ each other</span></div></li></ul><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 14px;">-boundary validation: microservices approach to components/fxns each doing own input validation on server-side, data validation occurs at each trust boundary that gets crossed</span></div><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 14px;">typical example: </span></div><ol><li><div>app received user login details, form handler validates input</div></li><li><div><span style="font-size: 14px;">app performs SQL query to verify user creds. malicious chars are escaped before query hits db</span></div></li><li><div><span style="font-size: 14px;">after login, app passes data to SOAP services, XML safely encoded</span></div></li><li><div><span style="font-size: 14px;">app displays user account info to user, sanitise XSS in returned page </span></div></li></ol><div><br/></div><div><img src="3%20User%20Input.html.resources/Screenshot%20from%202019-06-05%2021-16-32.png" height="603" width="920"/><br/></div><div><br/></div><div><b><u><font style="font-size: 18px;">Multistep Validation and Canonicalization</font></u></b></div><div><span style="font-size: 14px;">user input manipulated across several steps as part of validation logic can create problems, so attackers plan for it:</span></div><div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;script&gt; #gets escaped</div><div>&lt;scr&lt;script&gt;ipt&gt; #gets inputed to plan for escape</div></div></div><div><br/></div><div>canonicalization: process of converting/decoding data into common char set</div><div>-attacker can pick suitable encoding scheme to bypass validation mech</div><div><i>example:</i></div><div>pre-canon: %2527 /benign</div><div>&lt;app url decode&gt;</div><div>post-canon: %27 /benign, no apostrophe</div><div>&lt;passes filters&gt;</div><div><span style="font-size: 14px;">&lt;further app url decode&gt;</span></div><div><span style="font-size: 14px;">input: %27 -&gt; ' /no longer benign</span></div><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 14px;">-multiple validation/canonicalization steps aren't all server-side</span></div><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 14px;">-best fit mapping: when converting one char set to another, &lt;&lt; &gt;&gt; (non-malicious) may get converted to &lt;&gt; (malicious)</span></div><div><span style="font-size: 14px;">-&gt;smuggles blocked chars </span></div><div><span style="font-size: 14px;"><br/></span></div><div><span style="font-size: 14px;">-one approach around this: recursive sanitization, but problematic character can create infinite loop</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>